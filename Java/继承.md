# super关键字的用法：  
因为子类无法访问父类的域，所以使用super.访问器，得到父类的域;super不是一个类的引用，只是一个指示编译器去访问父类方法的一个关键字  
若父类没有无参构造器，则需要在构建子类时使用super.父类构造器，不然会报错。

---
  
# 多态：  
虚拟机根据类变量实际引用的对象调用正确的方法。
使用多态数组出错的原因：当把子类数组赋给父类数组变量，但是父类数组是无法调用子类数组独有的方法，会出异常
## 多态的原理：
这里需要引出一个方法表的概念：对于每一个类都会有一个方法表。
如下代码：

```java
class Demo1{
	public void demo1(){
	}
	public void demo2(){
	}
}
class Demo2 extends Demo1{
	public void demo2(){
	}
	public void demo3(){
	}
}
```
Demo1类的方法表为：

```java
Demo1:
	demo1() -> Demo1.demo1()
	demo2() -> Demo1.demo2()
```
Demo2类的方法表为：

```java
Demo2:
	demo1() -> Demo1.demo1()
	demo2() -> Demo2.demo2()
	demo3() -> Demo2.demo3()
```
这里引申一下：Java中方法的调用是先查看这个类的方法表看能否找到这个方法和对应的参数，然后执行，没有就报错。

由方法表可知：

 1. 子类继承的父类的方法，作用的范围是父类
 2. 子类重写父类的方法（重写要求，变量类型和方法名相同），作为范围为子类，无法调用父类的隐藏变量。所以子类重写后若想访问父类的域，需要调用super.父类域访问器。
 3. 子类重写方法后，方法在方法表中位置不变，只是有父类变成子类

**注意：** 如果将子类对象赋给父类变量时，该变量只能访问父类的方法（可多态），但不能执行子类特有的方法。
原理：在Java中变量的类型不仅规定了读取内存的方式，还规定了大小。拿C++距离，int* 类型要读取四个字节，但没有规定要读多少。
在多态时，父类变量读取子类方法表的大小只有父类方法表那么大，例如：

```java
Demo1 demo = new Demo2;
```
那么demo可以读取的方法表为
```java
Demo2:
	demo1() -> Demo1.demo1()
	demo2() -> Demo2.demo2()
```

另注：在Java中，隐藏方法不会继承，域或者说变量和静态方法都无法多态。原因：域的访问是通过编译器解析，而不是查看方法表，而静态方法是与类捆绑的。

----

final类与方法：若类被修饰为final那么这个类便无法修饰，方法被修饰final，便无法被重写。

抽象类：拥有被abstract修饰的方法的类。
抽象类的子类要求一定要重写抽象方法
###  抽象类与接口的共同点与区别：
#### 共同点：
1. 都无法被实例化
2. 子类都需要重写方法
3. 可以定义类变量和接口变量
#### 不同点：
1. 接口是不能有除静态变量外其他变量，而抽象类作为类可以有私有变量
2. 类可以继承多个接口，但只能继承一个抽象类


---

继承的设计技巧
1. 把公共操作和域放在超类：降低代码耦合性，提高代码复用率
2. 不要使用受保护的域：子类可以访问，同包可以访问，破坏封装
3. 使用继承实现“is-a”
4. 除非所有的继承方法都有意义，否则不要使用继承0
5. 在覆盖方法时，不要改变预期的行为：覆盖一个方法时，不要毫无理由的改变行为的内涵
6. 使用多态，而非类型信息：假设要根据类的不同，执行同一个方法，那么用多态，比用多个类型，易于维护和扩展。
7. 少用反射：反射比较慢，小范围还好，次数一多，时间很长。(写轮子用的多，写应用就算了)，编译器无法查出问题，要靠运行踩坑

