# Mysql锁机制

#### 一、Mysql的锁分类

1. 从性能上分：悲观锁与乐观锁
2. 从锁粒度上分：表锁与行锁
3. 从数据操作类型上分：读锁与写锁

#### 二、全局锁

就是对整个数据库加锁。Mysql提供了一个加锁方法FTWRL(flush table with read lock)。使用这个命令时，整个库会进入只读状态，其他线程的CUD，和数据定义语句(建表，修改表结构)以及更新类事务的提交语句。

这个使用场景就是全库逻辑备份，但是如果直接将全库设为只读，不是很好。

问题如下：

- 如果是封的主库，那备份期间整个库都不能更新，那业务就要停滞
- 如果封的从库，那从库不能执行主库同步过来的binlog，那就主从延迟了

如果不加锁，那就导致，每个表复制的不是同一个逻辑时间点，视图逻辑不一致

当然有另一种方式可以得到逻辑相同的视图，在可重复读的隔离级别下开启一个事务

官方自带的逻辑备份工具mysqldump，当使用参数为single-transaction的时候，导数据之前会启动一个事务，确保拿到一个一致性的视图。但是这个方法是需要存储引擎支持事务，还要是可重复读这个隔离级别。如果用的是MyISAM，那就只能FTWRL。

同样是数据库只读，为什么不用set global readonly=true？

虽然这个方式也可以让数据库变为只读，但有以下几个问题：

- 在有些系统中，比如主从分离，是要用readonly做判断逻辑，判断哪个是主库，哪个是从库，修改的影响有点大
- 在异常处理上，如果FTWRL的客户端，断开，那么Mysql会释放这个锁，但是用readonly是不行的，就算出异常，数据库依然是readonly

#### 三、表锁与元数据锁（MDL）

1. 表锁语法为lock tables ... read/write。可以使用unlock tables主动释放锁，也可以在客户端断开时自动释放。

   - 如果给表加的读锁，那么其他线程可以读这张表，但其他线程写这张表会被阻塞，直到锁被释放。给表加锁的线程，可以读这张表，但是不能写，写就报错
   - 如果给表加的写锁，那么其他线程不管读写，都是会阻塞。当前线程读写操作都可以执行

2. 元数据锁：相对于表锁会复杂一些。MDL的作用是保证读写的正确性，别出现，这边CRUD的时候，另一个线程把这个字段给删了的事情。

   - 当进行CRUD的操作是会加MDL读锁
   - 进行表结构更改操作时加MDL写锁

   读锁之间是不互斥的，可以多个线程进行CRUD操作，读写锁之间，写锁之间是互斥的，要保证结构的正确性

   虽然MDL是系统自动加，但是有一个机制不能忽略，不然直接整库都挂，问题如下：

   图来自于极客时间Mysql45讲

![img](https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg)

session A启动，此时对表加个MDL读锁，sessionB也需要读锁，所以不冲突，但是到C，就不对劲了，C是对表加个字段，这个要的是写锁，但是前面的读锁没释放。写锁被阻塞，后续所有对该表的操作全被阻塞，要是客户端再有个重试机制，那该库线程直接爆满了。

> MDL锁在执行时加，但是在事务提交时锁被释放

>关于为什么写锁阻塞之后，其他操作全被阻塞
>
>申请MDL的锁的操作会形成一个队列，如果队列中有写锁请求，那么当前操作被阻塞，后续的请求也被阻塞。事务一旦申请到MDL操作，直到事务提交才被释放（特殊情况：事务中有数据库结构修改操作，在该操作结束后，会自动提交事务，以保证该DDL语句是单独的事务，不会因为别的问题回滚，同时保证这个写锁释放。后续的sql语句都是单独语句，不算在本次事务，回滚无效）

不过在使用的时候，还是有点区别，会出现一个sessionD“插队”的情况，AB提交之后，C依然被阻塞，只有D提交之后，C才会执行下去

这个是涉及到online ddl，毕竟ddl直接锁表，影响性能，不锁，无法避免CRUD的影响。所以Mysql用了online ddl

1. 先拿MDL写锁，确定这一时刻该表没有被锁
2. 降成MDL读锁，这样可以让其他CRUD业务正常运行
3. 申请空间，进行DDL操作
4. 升级成MDL写锁，这个时候如果有其他读锁，会被阻塞，等待读锁释放
5. 升到写锁，替换表，释放写锁

>如果没有阻塞的情况下，1，2，4，5很快，主要是3很慢，在3的时间，可以进行CRUD操作，叫online，上面的例子，是，AB都没提交，表还在被读锁锁着，所以C卡在了第一步。而第二个例子，是AB提交，C拿到了写锁，降级为读锁，所以D能拿到读锁
>
>图片出自
>
>[mysql MDL读写锁阻塞，以及online ddl造成的“插队”现象](https://blog.csdn.net/q2878948/article/details/96430129)
>
>![mdl各个session流程实例](https://img-blog.csdnimg.cn/2019071820433258.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3EyODc4OTQ4,size_16,color_FFFFFF,t_70)

那么如何安全的给小表加字段

- 解决长事务，事务不提交就一直占着MDL读锁。可以考虑暂停DDL，或者kill掉长事务
- 但是在这个表用的很频繁，还要加字段，那kill就不好使了。这个时候可以在DDL操作语句，加一个等待时间，超过了这个等待时间就先停下，别当误后面的业务语句。后续再进行修改
