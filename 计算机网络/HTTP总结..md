#### 一、从输入网址到获得网页，整个流程
首先客户端访问dns服务器（**dns相关**），获得服务器的ip地址，用ARP协议转成MAC地址。客户端与服务器简历TCP连接（三次握手），客户端发送请求，服务端接收请求，返回响应，TCP四次挥手，前端解析。

#### 二、HTTP请求的方式
1. GET请求：
向服务器发送一个请求，得到一个响应。GET本身是安全且幂等的，就是请求各资源。
2. POST请求
向服务器提交一个数据，比如表单提交，post会把数据放在请求体里。post请求不是安全的，因为会修改服务器的数据。

#### 三、关于HTTP协议

1.  HTTP协议：
HTTP协议本身是无状态协议，所谓无状态就是一次HTTP请求结束后，下一次HTTP请求不会有上一次请求的信息。
为了解决这个问题，使用了cookie的技术。当客户端进行第一次请求时，服务器响应的响应头中有cookie相关的信息；后续客户端再发送请求时，会将cookie一同发过去，这样就获得了以前的信息。
2. HTTP状态码
- 200 成功响应 
- 204 请求成功但无资源返回
- 206 客户端只请求了部分资源，服务器只对部分资源进行GET方法
- 301 永久重定向
- 302 临时重定向
- 303 与302类似，希望客户端在访问一个URI时，通过GET请求重定向到另一个URI。
- 304 发送附带条件的请求时，条件不满足时返回
- 400 请求报文有误，服务器无法识别
- 401 请求需要验证
- 403 请求的资源禁止访问
- 404 请求资源不存在
- 500 服务器内部错误
- 503 服务器在忙

3. HTTP报文：报文都是由报文首部、空行、报文体
- 请求报文：由请求行(方法，HTTP版本，URL)，HTTP首部字段（请求首部字段，通用首部字段，实体首部字段）
- 响应报文：由状态行(HTTP版本，状态码)，HTTP首部字段(响应首部字段，通用首部字段，实体首部字段)

4. HTTP版本的区别
 - 1.0与1.1的区别：
 a. 1.0是短连接，一个请求对应一个tcp连接，这样花费太大了，而1.1是持久化连接，一个TCP连接可以处理多个HTTP请求，不过是接收到一个HTTP响应后，才发下一个HTTP请求。
 b. 其实1.1提出了管程化的概念，可以同时发出多个HTTP请求，但是只是概念，因为在这个时候传多个HTTP请求，服务器就不知道哪个是哪个了。
 c. 实现断点续传，实际上是请求头分块传输编码，实体分块传输
- 2.0的变化：
2.0最重要就是多路复用与数据流,解决了1.1时一个请求一个请求的请求阻塞的问题。
所谓多路复用就是移除了1.1串行请求，不必排队等待，当TCP请求建立之后，后续都是按流的形式传输。一个请求对应一个id流传输的基本单位就是二进制帧，有很多类型，比如(HEADERS FRAME)头二进制帧，(DATA FRAME)实体二进制帧。请求有请求HEADS FRAME，响应有响应HEADS FRAME,响应DATA FRAME组成。一个请求一个响应组成了一个流。
2.0会压缩头，如果发送的多个请求的头是相同或相似，2.0会消除重复。
 > HPACK算法，客户端和服务器同时维护一张头信息表，所有字段都会存到这个表，生成一个索引号，后续只需要发索引号就可以

总结：
- 1.0 -> 1.1 增加了持久化连接，提出了管程化的概念，增加了断点续传的功能

- 1.1 -> 2.0 通过多路复用解决了请求阻塞，还有二进制分帧，头部压缩，服务器推送

#### 四、HTTP协议与HTTPS协议的区别

- 在访问上HTTP用的http:// HTTPS用的https://
- 在默认端口上，HTTP为80，HTTPS为443
- 在安全性上，HTTP是不安全的，HTTPS安全
- HTTP作用于应用层，HTTPS的加密在传输层
- HTTP不能对内容加密，HTTPS可以对传输内容加密
- HTTP不需要证书，HTTPS需要CA的证书

#### 五、关于HTTPS

1. 为什么要有HTTPS：
	在使用HTTP协议的情况下会有三种不安全的情况
	1. 信息泄露：因为HTTP是明文传输，所以账号密码有泄露风险
	2. 内容篡改：服务器发来的信息，中间人改一改，加一些垃圾内容
	3. 冒充风险：客户端往服务器发的时候，中间人修改请求，去了另一个假冒网站
2. HTTPS如何解决这三种情况：
	1. 通过加密的形式，防止信息泄露
	2. 通过摘要的形式，确保通信内容不会被篡改
	3. 通过数字证书，保证不会访问冒充的网站

2. 对称加密与非对称加密：
	- 对称加密：加密与解密用同一个秘钥
	- 非对称加密：有一个公有秘钥和一个相对应的私有秘钥；公有秘钥加密的数据，只有对应私有秘钥能解开，私有秘钥加密的数据，只有对应的公有秘钥能解开。
3. 摘要算法：
通过摘要算法，将明文生成一个摘要，将明文与摘要通过会话秘钥加密，另一端，通过会话秘钥解密，对明文用相同的摘要算法，获得另一个摘要，与原摘要进行比对，判断内容是否有修改
4. 数字证书
原本客户端是先向服务器要公钥，后续用公钥进行加密。
这种情况，如果中间人将公钥替换为自己的公钥，那信息还是泄露了。
这里就要使用数字证书了，借助第三方权威机构CA，将服务器公钥放在CA颁发的数字证书中，只要证书可信，公钥就可信。
流程如下：
	1. 服务器将自己的公钥注册到CA
	2. CA用自己的私钥，将服务器的公钥数字签名，并颁发数字证书
	3. CA的公钥是内嵌到浏览器或操作系统内，客户端拿到数字证书后，通过CA公钥确认证书的有效性（包括服务器公钥和CA的数字签名）
	4. 获得公钥后，用公钥进行加密

4. SSL/TLS协议基本流程：
 ![微信图片_20210321203141.jpg](http://172.81.243.159:8090/upload/2021/03/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210321203141-2a631c90d60f40b9b8925244f05f120f.jpg)
	- 客户端发送HTTPS的请求，包括一个生成的随机数，支持的密码套件，TLS版本
	- 服务器将证书，选择的密码套件和一个服务器生成的随机数发回去
	- 客户端检验证书合法性，比如是否超期，请求的域名和证书域名是否匹配等，取出服务器的公钥
	- 客户端生一个用于加密的随机数。将客户端生成的两个随机数，与服务器生成的随机数，用双方协商的加密算法，算出会话秘钥。用公钥进行加密，发给服务器端。
	- 服务器收到这个会话秘钥，并用与公钥匹配的私钥进行解密，得到客户端的KEY
	- 客户端发送，后续改用会话秘钥加密通信的通知
	- 客户端发送握手期间所有数据的摘要
	- 服务器发送后续改用会话秘钥加密通信的通知
	- 服务器发送握手期间所有数据的摘要
	- 服务器用KEY对要传的HTTP数据进行加密，将密文发给客户端
	- 客户端用KEY进行解密得到数据

#### 六、关于HTTP3.0的补充
HTTP2.0还是有一些缺陷，是因为，2.0基于TCP协议，而TCP协议有一个丢包重传。在多个HTTP请求都在一个TCP长连接下，任何一个请求丢包了，所有请求都要阻塞，直到，这个包重传。
> 1.1中管道传输请求阻塞，其他请求也会阻塞
> 2.0中多个请求用一个TCP连接，丢一个就阻塞所有请求等待重传

这都是因为用TCP的原因(毕竟可靠的连接)，所以3.0就换成了UDP
UDP不管顺序，也不管丢包，所以1.1与2.0的问题都解决了
UDP虽然是不可靠传输，但是基于UDP的QUIC协议可以实现类似于TCP的可靠传输
> - QUIC的可靠传输，在某个流发生丢包之后，只阻塞这个流，其他流不会受到影响　
> - HTTPS要建立一个连接需要TCP三次握手，TLS三次握手，QUIC直接将这六次交互，合并为三次
