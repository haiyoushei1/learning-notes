一、从输入网址到获得网页，整个流程
首先客户端访问dns服务器（**dns相关**），获得服务器的ip地址，用ARP协议转成MAC地址。客户端与服务器简历TCP连接（三次握手），客户端发送请求，服务端接收请求，返回响应，TCP四次挥手，前端解析。

二、HTTP请求的方式
1. GET请求：
向服务器发送一个请求，得到一个响应。GET本身是安全且幂等的，就是请求各资源。
但在服务端使用restful获取数据进行修改的时候GET是不安全的，因为这些数据在URL里，很容易进行网安破解。
2. POST请求
向服务器提交一个数据，比如表单提交，post会把数据放在请求头里，不容易泄露。

三、关于HTTP协议

1.  HTTP协议：
HTTP协议本身是无状态协议，所谓无状态就是一次HTTP请求结束后，下一次HTTP请求不会有上一次请求的信息。
为了解决这个问题，使用了cookie的技术。当客户端进行第一次请求时，服务器响应的响应头中有cookie相关的信息；后续客户端再发送请求时，会将cookie一同发过去，这样就获得了以前的信息。
2. HTTP状态码
- 200 成功响应 
- 204 请求成功但无资源返回
- 206 客户端只请求了部分资源，服务器只对部分资源进行GET方法
- 301 永久重定向
- 302 临时重定向
- 303 与302类似，希望客户端在访问一个URI时，通过GET请求重定向到另一个URI。
- 304 发送附带条件的请求时，条件不满足时返回
- 400 请求报文有误，服务器无法识别
- 401 请求需要验证
- 403 请求的资源禁止访问
- 404 请求资源不存在
- 500 服务器内部错误
- 503 服务器在忙

3. HTTP报文：报文都是由报文首部、空行、报文体
- 请求报文：由请求行(方法，HTTP版本，URL)，HTTP首部字段（请求首部字段，通用首部字段，实体首部字段）
- 响应报文：由状态行(HTTP版本，状态码)，HTTP首部字段(响应首部字段，通用首部字段，实体首部字段)

4. HTTP版本的区别
 - 1.0与1.1的区别：
 a. 1.0是短连接，一个请求对应一个tcp连接，这样花费太大了，而1.1是持久化连接，一个TCP连接可以处理多个HTTP请求，不过是接收到一个HTTP响应后，才发下一个HTTP请求。
b. 其实1.1提出了管程化的概念，可以同时发出多个HTTP请求，但是只是概念，因为在这个时候传多个HTTP请求，服务器就不知道哪个是哪个了。
c. 实现断点续传，实际上是请求头分块传输编码，实体分块传输
- 2.0的变化：
2.0最重要就是多路复用,解决了1.1时一个请求一个请求的请求阻塞的问题。
所谓多路复用就是当TCP请求建立之后，后续都是按流的形式传输。一个连接对应一个id。流传输的基本单位就是二进制帧，有很多类型，比如(HEADERS FRAME)头二进制帧，(DATA FRAME)实体二进制帧。请求有请求HEADS FRAME，响应有响应HEADS FRAME,响应DATA FRAME组成。一个请求一个响应组成了一个流。

总结：
- 1.0 -> 1.1 增加了持久化连接，提出了管程化的概念，增加了断点续传的功能

- 1.1 -> 2.0 通过多路复用解决了请求阻塞，还有二进制分帧，头部压缩，服务器推送

四、HTTP协议与HTTPS协议的区别

- 在访问上HTTP用的http:// HTTPS用的https://
- 在默认端口上，HTTP为80，HTTPS为443
- 在安全性上，HTTP是不安全的，HTTPS安全
- HTTP作用于应用层，HTTPS的加密在传输层
- HTTP不能对内容加密，HTTPS可以对传输内容加密
- HTTP不需要证书，HTTPS需要CA的证书

五、关于HTTPS

1. 为什么要有HTTPS：
因为HTTP是明文传输，会有信息泄露的问题，HTTPS就是在HTTP上面加了一层加密。
2. 对称加密与非对称加密：
- 对称加密：加密与解密用同一个秘钥
- 非对称加密：有一个公有秘钥和一个相对应的私有秘钥；公有秘钥加密的数据，只有对应私有秘钥能解开，私有秘钥加密的数据，只有对应的公有秘钥能解开。
3. HTTPS工作原理：
 ![微信图片_20210321203141.jpg](http://172.81.243.159:8090/upload/2021/03/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210321203141-2a631c90d60f40b9b8925244f05f120f.jpg)
- 客户端发送HTTPS的请求
- 服务器将证书发给客户端
- 客户端检验证书合法性，比如是否超期，请求的域名和证书域名是否匹配等
- 客户端生一个用于加密的KEY，并用公钥进行加密
- 服务器收到这个KEY，并用与公钥匹配的私钥进行解密，得到客户端的KEY
- 服务器用KEY对要传的HTTP数据进行加密，将密文发给客户端
- 客户端用KEY进行解密得到数据

4. 优化方案：
这种对称加密加非对称加密的方案确实很完美，但是这么传还是避免不了信息泄露，如果有个中间人，在服务器发公钥的时候，中间，咔这么一下给换了，信息还是泄露了。
![微信图片_20210321204207.jpg](http://172.81.243.159:8090/upload/2021/03/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210321204207-27336183f31f404cb41c1c19dbc11f44.jpg)
这个时候就引入一个公信机构CA，服务器在发之前，先去CA申请一个证书(比如配nginx会有一个crt文件，一个key文件)
数字证书里包含有证书持有者、证书有效期、公钥等信息
但是这个时候还是不能避免中间泄露，我直接改证书公钥，你拿我没办法。这个时候就体现出了私钥的另一个作用就是数字签名。
所谓数字签名就是CA有自己的一套公钥私钥，我们先把证书明文(就上面那个发的证书的内容)进行哈希，得到这个哈希值，我们再用私钥加密得到这么个数字签名。
- 那么客户端在接收到证书的时候，将证书分成明文TEXT和数字标签SIG1。
- 我们先用公钥对数字签名进行解析，得到SIG2。
- 然后再用CA证书声明的哈希函数对明文进行哈希得到TEXT2，将这两个进行匹配，要是相等，说明证书没问题。
因为CA的公钥和证书是浏览器自嵌的，中间人就获取不到CA私钥，中间人就算改证书公钥，这么一判断，哈希值对不上，这样就安全了




